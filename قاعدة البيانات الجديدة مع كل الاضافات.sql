-- =================================================================
-- == قاعدة البيانات الكاملة والنهائية للمشروع مع كل الإضافات ==
-- =================================================================

-- حذف الجداول القديمة إذا كانت موجودة لضمان عدم التعارض
DROP TABLE IF EXISTS user_answers CASCADE;
DROP TABLE IF EXISTS quiz_results CASCADE;
DROP TABLE IF EXISTS student_first_attempt_results CASCADE;
DROP TABLE IF EXISTS user_activated_courses CASCADE;
DROP TABLE IF EXISTS questions CASCADE;
DROP TABLE IF EXISTS quiz_models CASCADE;
DROP TABLE IF EXISTS courses CASCADE;
DROP TABLE IF EXISTS teachers CASCADE;
DROP TABLE IF EXISTS users CASCADE;
DROP TABLE IF EXISTS codes CASCADE;
DROP TABLE IF EXISTS phone CASCADE;

-- ==============================================
-- إنشاء الجداول الأساسية
-- ==============================================

-- 1. جدول المعلمين
CREATE TABLE public.teachers (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    username VARCHAR(100) NOT NULL UNIQUE,
    password_hash VARCHAR(255) NOT NULL,
    full_name VARCHAR(255) NOT NULL,
    email VARCHAR(255) UNIQUE,
    created_at TIMESTAMPTZ DEFAULT NOW() NOT NULL
);

-- 2. جدول الدورات
CREATE TABLE public.courses (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  teacher_id BIGINT REFERENCES public.teachers(id) ON DELETE SET NULL,
  created_at TIMESTAMPTZ DEFAULT NOW() NOT NULL,
  title TEXT NOT NULL,
  description TEXT,
  is_free BOOLEAN DEFAULT FALSE NOT NULL,
  difficulty TEXT,
  category TEXT,
  icon TEXT,
  rating REAL DEFAULT 0,
  students INTEGER DEFAULT 0,
  course_type TEXT,
  is_visible BOOLEAN DEFAULT TRUE NOT NULL
);

-- 3. جدول نماذج الاختبار
CREATE TABLE public.quiz_models (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    course_id BIGINT NOT NULL REFERENCES public.courses(id) ON DELETE CASCADE,
    teacher_id BIGINT REFERENCES public.teachers(id) ON DELETE SET NULL,
    title TEXT NOT NULL,
    timer_type TEXT NOT NULL DEFAULT 'per_question', -- 'per_question', 'total_time', 'both'
    total_time_seconds INTEGER,
    questions_count INTEGER DEFAULT 0 NOT NULL,
    created_at TIMESTAMPTZ DEFAULT NOW() NOT NULL,
    is_visible BOOLEAN DEFAULT TRUE NOT NULL
);

-- 4. جدول الأسئلة (مع حقل الترتيب الجديد)
CREATE TABLE public.questions (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  quiz_model_id BIGINT NOT NULL REFERENCES public.quiz_models(id) ON DELETE CASCADE,
  created_at TIMESTAMPTZ DEFAULT NOW() NOT NULL,
  question_text TEXT,
  question_image TEXT,
  options JSONB, 
  correct INTEGER NOT NULL,
  explanation TEXT,
  needs_calculator BOOLEAN DEFAULT FALSE NOT NULL,
  time_limit_seconds INTEGER DEFAULT 60 NOT NULL,
  question_order INTEGER -- *** NEW: Column for reordering questions ***
);

-- 5. جدول أكواد التفعيل
CREATE TABLE public.codes (
    id SERIAL PRIMARY KEY,
    code VARCHAR(20) NOT NULL UNIQUE,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    used_at TIMESTAMP WITH TIME ZONE,
    use_code BOOLEAN DEFAULT FALSE,
    used_by VARCHAR(255),
    is_active BOOLEAN DEFAULT TRUE
);

-- 6. جدول المستخدمين (الهاتف)
CREATE TABLE public.phone (
    id SERIAL PRIMARY KEY,
    first_name VARCHAR(100) NOT NULL,
    middle_name VARCHAR(100) NOT NULL,
    last_name VARCHAR(100) NOT NULL,
    phone_number VARCHAR(20) NOT NULL UNIQUE,
    email VARCHAR(255) NOT NULL UNIQUE,
    verification_code VARCHAR(6),
    is_verified BOOLEAN DEFAULT FALSE NOT NULL,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- 7. جدول الدورات المفعلة للمستخدمين
CREATE TABLE public.user_activated_courses (
    id SERIAL PRIMARY KEY,
    phone_number VARCHAR(20) NOT NULL REFERENCES public.phone(phone_number) ON DELETE CASCADE,
    course_id INTEGER NOT NULL REFERENCES public.courses(id) ON DELETE CASCADE,
    activated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    activation_code VARCHAR(20),
    UNIQUE(phone_number, course_id)
);

-- 8. جدول نتائج الاختبارات
CREATE TABLE public.quiz_results (
    id SERIAL PRIMARY KEY,
    phone_number VARCHAR(20) NOT NULL REFERENCES public.phone(phone_number) ON DELETE CASCADE,
    course_id INTEGER NOT NULL,
    quiz_model_id INTEGER NOT NULL,
    score INTEGER DEFAULT 0,
    total_questions INTEGER DEFAULT 0,
    percentage DECIMAL(5,2) DEFAULT 0.00,
    completed_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    session_id VARCHAR(100)
);

-- 9. جدول إجابات المستخدمين
CREATE TABLE public.user_answers (
    id SERIAL PRIMARY KEY,
    phone_number VARCHAR(20) NOT NULL REFERENCES public.phone(phone_number) ON DELETE CASCADE,
    quiz_model_id INTEGER NOT NULL,
    question_id INTEGER NOT NULL,
    question_number INTEGER NOT NULL,
    question_text TEXT NOT NULL,
    selected_answer INTEGER NOT NULL,
    correct_answer INTEGER NOT NULL,
    is_correct BOOLEAN NOT NULL,
    answered_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    quiz_session_id VARCHAR(100)
);

-- 10. جدول المحاولة الأولى للطلاب
CREATE TABLE public.student_first_attempt_results (
    id SERIAL PRIMARY KEY,
    phone_number VARCHAR(20) NOT NULL REFERENCES public.phone(phone_number) ON DELETE CASCADE,
    course_id INTEGER NOT NULL REFERENCES public.courses(id) ON DELETE CASCADE,
    student_name TEXT,
    course_title TEXT,
    final_score INTEGER NOT NULL,
    total_questions INTEGER NOT NULL,
    percentage DECIMAL(5,2) NOT NULL,
    attempted_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    UNIQUE (phone_number, course_id)
);

-- ==============================================
-- إنشاء الفهارس لتحسين الأداء
-- ==============================================
CREATE INDEX idx_codes_code ON codes(code);
CREATE INDEX idx_phone_number ON phone(phone_number);
CREATE INDEX idx_phone_email ON phone(email);
CREATE INDEX idx_user_activated_courses_phone ON user_activated_courses(phone_number);
CREATE INDEX idx_quiz_results_phone ON quiz_results(phone_number);
CREATE INDEX idx_user_answers_phone ON user_answers(phone_number);
CREATE INDEX idx_questions_quiz_model_id ON questions(quiz_model_id);

-- ==============================================
-- الدوال (Functions)
-- ==============================================

-- *** NEW: دالة لتعيين الترتيب المبدئي للأسئلة ***
CREATE OR REPLACE FUNCTION set_initial_question_order()
RETURNS void AS $$
BEGIN
  UPDATE public.questions q
  SET question_order = sub.rn
  FROM (
    SELECT 
      id, 
      ROW_NUMBER() OVER (PARTITION BY quiz_model_id ORDER BY created_at, id) as rn
    FROM public.questions
  ) AS sub
  WHERE q.id = sub.id AND q.question_order IS NULL;
END;
$$ LANGUAGE plpgsql;

-- *** NEW: دالة لتحديث ترتيب الأسئلة ***
CREATE OR REPLACE FUNCTION update_question_order(p_question_ids BIGINT[])
RETURNS void AS $$
DECLARE
    v_quiz_model_id BIGINT;
BEGIN
    SELECT quiz_model_id INTO v_quiz_model_id FROM public.questions WHERE id = p_question_ids[1];
    IF v_quiz_model_id IS NULL THEN
        RAISE EXCEPTION 'Invalid question ID provided.';
    END IF;
    UPDATE public.questions
    SET question_order = array_position(p_question_ids, id)
    WHERE id = ANY(p_question_ids) AND quiz_model_id = v_quiz_model_id;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- *** NEW: دالة لنسخ سؤال ***
CREATE OR REPLACE FUNCTION duplicate_question(p_question_id BIGINT)
RETURNS TABLE(new_question_id BIGINT) AS $$
DECLARE
    original_question RECORD;
    new_id BIGINT;
    max_order INTEGER;
BEGIN
    SELECT * INTO original_question FROM public.questions WHERE id = p_question_id;
    IF NOT FOUND THEN
        RAISE EXCEPTION 'Question with ID % not found', p_question_id;
    END IF;
    SELECT COALESCE(MAX(question_order), 0) INTO max_order
    FROM public.questions
    WHERE quiz_model_id = original_question.quiz_model_id;
    INSERT INTO public.questions (
        quiz_model_id,
        question_text,
        question_image,
        options,
        correct,
        explanation,
        time_limit_seconds,
        needs_calculator,
        question_order
    )
    VALUES (
        original_question.quiz_model_id,
        original_question.question_text || ' (نسخة)',
        original_question.question_image,
        original_question.options,
        original_question.correct,
        original_question.explanation,
        original_question.time_limit_seconds,
        original_question.needs_calculator,
        max_order + 1
    )
    RETURNING id INTO new_id;
    RETURN QUERY SELECT new_id;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- (بقية الدوال تبقى كما هي)
CREATE OR REPLACE FUNCTION add_phone_registration(
    p_first_name VARCHAR(100),
    p_middle_name VARCHAR(100),
    p_last_name VARCHAR(100),
    p_phone_number VARCHAR(20),
    p_email VARCHAR(255)
)
RETURNS BOOLEAN AS $$
BEGIN
    INSERT INTO phone (first_name, middle_name, last_name, phone_number, email)
    VALUES (p_first_name, p_middle_name, p_last_name, p_phone_number, p_email)
    ON CONFLICT (phone_number) 
    DO UPDATE SET 
        first_name = EXCLUDED.first_name,
        middle_name = EXCLUDED.middle_name,
        last_name = EXCLUDED.last_name,
        email = EXCLUDED.email,
        updated_at = NOW();
    RETURN TRUE;
EXCEPTION
    WHEN unique_violation THEN
        RETURN FALSE;
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION get_user_info(p_phone_number VARCHAR(20))
RETURNS TABLE(
    first_name VARCHAR(100),
    middle_name VARCHAR(100),
    last_name VARCHAR(100),
    email VARCHAR(255),
    created_at TIMESTAMP WITH TIME ZONE
) AS $$
BEGIN
    RETURN QUERY
    SELECT 
        p.first_name,
        p.middle_name,
        p.last_name,
        p.email,
        p.created_at
    FROM phone p
    WHERE p.phone_number = p_phone_number;
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION generate_unique_code(code_length INTEGER DEFAULT 12)
RETURNS VARCHAR(20) AS $$
DECLARE
    new_code VARCHAR(20);
    code_exists BOOLEAN;
BEGIN
    LOOP
        new_code := LOWER(SUBSTRING(encode(gen_random_bytes(code_length), 'hex'), 1, code_length));
        SELECT EXISTS(SELECT 1 FROM codes WHERE code = new_code) INTO code_exists;
        IF NOT code_exists THEN
            RETURN new_code;
        END IF;
    END LOOP;
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION create_new_activation_code()
RETURNS VARCHAR(20) AS $$
DECLARE
    new_code VARCHAR(20);
BEGIN
    new_code := generate_unique_code();
    INSERT INTO codes (code, is_active, use_code) VALUES (new_code, TRUE, FALSE);
    RETURN new_code;
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION generate_bulk_codes(codes_count INTEGER DEFAULT 10)
RETURNS TABLE(generated_code VARCHAR(20)) AS $$
DECLARE
    i INTEGER;
    new_code VARCHAR(20);
BEGIN
    FOR i IN 1..codes_count LOOP
        new_code := create_new_activation_code();
        generated_code := new_code;
        RETURN NEXT;
    END LOOP;
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION validate_activation_code(code_to_check VARCHAR(20))
RETURNS TABLE(is_valid BOOLEAN, use_code BOOLEAN, used_by VARCHAR(255)) AS $$
BEGIN
    RETURN QUERY SELECT (c.is_active AND c.code IS NOT NULL), c.use_code, c.used_by
    FROM codes c WHERE c.code = code_to_check;
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION mark_code_as_used(code_to_update VARCHAR(20), user_phone VARCHAR(20))
RETURNS TABLE(success BOOLEAN) AS $$
BEGIN
    UPDATE codes SET used_at = NOW(), use_code = TRUE, used_by = user_phone
    WHERE code = code_to_update AND is_active = TRUE AND use_code = FALSE;
    RETURN QUERY SELECT FOUND;
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION public.master_activate_course(
    p_phone_number text,
    p_course_id integer,
    p_activation_code text
)
RETURNS jsonb
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
    code_record record;
BEGIN
    IF NOT EXISTS (SELECT 1 FROM public.phone WHERE phone_number = p_phone_number) THEN
        RETURN jsonb_build_object('success', false, 'message', 'المستخدم صاحب هذا الرقم غير موجود.');
    END IF;
    SELECT * INTO code_record FROM public.codes WHERE code = p_activation_code;
    IF NOT FOUND THEN
        RETURN jsonb_build_object('success', false, 'message', 'كود التفعيل الذي أدخلته غير صالح.');
    END IF;
    IF code_record.use_code = TRUE THEN
        RETURN jsonb_build_object('success', false, 'message', 'هذا الكود مستخدم بالفعل من قبل.');
    END IF;
    IF EXISTS (SELECT 1 FROM public.user_activated_courses WHERE phone_number = p_phone_number AND course_id = p_course_id) THEN
        RETURN jsonb_build_object('success', false, 'message', 'هذه الدورة مفعلة لديك بالفعل.');
    END IF;
    INSERT INTO public.user_activated_courses (phone_number, course_id, activation_code)
    VALUES (p_phone_number, p_course_id, p_activation_code);
    UPDATE public.codes
    SET use_code = TRUE, used_at = NOW(), used_by = p_phone_number
    WHERE id = code_record.id;
    RETURN jsonb_build_object('success', true, 'message', 'تم تفعيل الدورة بنجاح!');
EXCEPTION
    WHEN OTHERS THEN
        RETURN jsonb_build_object('success', false, 'message', 'حدث خطأ غير متوقع في قاعدة البيانات: ' || SQLERRM);
END;
$$;

CREATE OR REPLACE FUNCTION is_course_activated_for_user(p_phone_number VARCHAR(20), p_course_id INTEGER)
RETURNS BOOLEAN AS $$
BEGIN
    RETURN EXISTS(SELECT 1 FROM user_activated_courses WHERE phone_number = p_phone_number AND course_id = p_course_id);
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION public.get_user_activated_courses(p_phone_number text)
RETURNS TABLE(course_id integer)
LANGUAGE plpgsql
AS $$
BEGIN
    RETURN QUERY
    SELECT uac.course_id
    FROM public.user_activated_courses uac
    WHERE uac.phone_number = p_phone_number;
END;
$$;

-- ==============================================
-- المشغلات (Triggers)
-- ==============================================

CREATE OR REPLACE FUNCTION update_quiz_model_questions_count()
RETURNS TRIGGER AS $$
BEGIN
  IF (TG_OP = 'INSERT') THEN
    UPDATE public.quiz_models SET questions_count = questions_count + 1 WHERE id = NEW.quiz_model_id;
  ELSIF (TG_OP = 'DELETE') THEN
    UPDATE public.quiz_models SET questions_count = questions_count - 1 WHERE id = OLD.quiz_model_id;
  END IF;
  RETURN NULL;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER questions_count_trigger
AFTER INSERT OR DELETE ON public.questions
FOR EACH ROW EXECUTE FUNCTION update_quiz_model_questions_count();

CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER update_phone_updated_at
BEFORE UPDATE ON public.phone
FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

-- ==============================================
-- إعداد الأذونات (Permissions)
-- ==============================================
ALTER TABLE public.courses DISABLE ROW LEVEL SECURITY;
ALTER TABLE public.quiz_models DISABLE ROW LEVEL SECURITY;
ALTER TABLE public.questions DISABLE ROW LEVEL SECURITY;
ALTER TABLE public.codes DISABLE ROW LEVEL SECURITY;
ALTER TABLE public.phone DISABLE ROW LEVEL SECURITY;
ALTER TABLE public.user_activated_courses DISABLE ROW LEVEL SECURITY;
ALTER TABLE public.quiz_results DISABLE ROW LEVEL SECURITY;
ALTER TABLE public.user_answers DISABLE ROW LEVEL SECURITY;
ALTER TABLE public.teachers DISABLE ROW LEVEL SECURITY;
ALTER TABLE public.student_first_attempt_results DISABLE ROW LEVEL SECURITY;

GRANT USAGE ON SCHEMA public TO postgres, anon, authenticated, service_role;
GRANT ALL ON ALL TABLES IN SCHEMA public TO postgres, anon, authenticated, service_role;
GRANT ALL ON ALL SEQUENCES IN SCHEMA public TO postgres, anon, authenticated, service_role;
GRANT ALL ON ALL FUNCTIONS IN SCHEMA public TO postgres, anon, authenticated, service_role;

-- ==============================================
-- انتهاء إعداد قاعدة البيانات
-- ==============================================
